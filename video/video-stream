#!/bin/bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

debug_print() {
    if [ -n "$DEBUG" ]; then
        echo "$1"
    fi
}

usage() {
    echo "usage: $(basename "$0") [ACTION] [SOURCE] [ID] [PREPROCESSING] [POSTPROCESSING]"
    echo "ACTION <start|stop> - template project language"
    echo "SOURCE <camera|file> - video source"
    echo "ID <1|2|..|all|movie.mp4> - camera id, all cameras or movie file name"
    echo "PREPROCESSING <true|false> - custom preprocessing element"
    echo "POSTPROCESSING <true|false> - custom postprocessing element"
    echo "example:"
    echo "./$(basename "$0") start camera 1 true true"
    echo "./$(basename "$0") stop camera all"
    echo "./$(basename "$0") start file movie.mp4 true true"
}

# Function to start the stream
start_stream() {
    [[ -s /home/fronti/.hailo/tappas/tappas_env ]] && . /home/fronti/.hailo/tappas/tappas_env
    export GST_PLUGIN_PATH+="$SCRIPT_DIR/video-processing"
    type=$1
    id=$2
    stream_id=$id

    if [ "$3" = "true" ]; then
        preprocessing="! preprocessing"
    fi

    if [ "$4" = "true" ]; then
        postprocessing="! postprocessing"
    fi

    if [ "$type" == "camera" ]; then
        if [ "$id" == "1" ]; then
            device_id="0"
        elif [ "$id" == "2" ]; then
            device_id="2"
        elif [ "$id" == "3" ]; then
            device_id="4"
        elif [ "$id" == "4" ]; then
            device_id="6"
        fi
        cam_device="/dev/video$device_id"
    fi

    if [ "$type" == "file" ]; then
        stream_id=0
    fi

    stop_stream $type $id
    echo "Starting $type $id..."

    # Stream settings
    in_format="video/x-raw,format=UYVY"
    fps="framerate=30/1"
    hd_in_resolution=",width=1920,height=1080,$fps"
    no_in_resolution=""

    if [ "$type" == "camera" ]; then
        in_resolution=$hd_in_resolution
    elif [ "$type" == "file" ]; then
        in_resolution=$no_in_resolution
    fi

    # Sources
    cam_src_element="v4l2src device=$cam_device ! $in_format $in_resolution "
    test_src_element="videotestsrc ! $in_format $in_resolution "
    hailo_src_element="videotestsrc pattern="ball" ! $in_format $in_resolution "
    movie_src_element="filesrc location=$SCRIPT_DIR/tests/movies/$id ! decodebin ! autovideoconvert"

    # Video processing
    cam_overlay="! textoverlay text="CAM$id" valignment=top halignment=left ! timeoverlay valignment=top halignment=right"
    no_overlay=""

    # Video processing
    hailo_stabilization="! queue leaky=no max-size-buffers=30 max-size-bytes=0 max-size-time=0 ! videoscale qos=false n-threads=2 ! video/x-raw, pixel-aspect-ratio=1/1 ! queue leaky=no max-size-buffers=30 max-size-bytes=0 max-size-time=0 ! videoconvert n-threads=2 qos=false ! queue leaky=no max-size-buffers=30 max-size-bytes=0 max-size-time=0 ! hailonet hef-path=/media/fronti/NVMe/hailo_4.15.0/tappas/apps/h8/gstreamer/resources/hef/yolov5m_wo_spp_60p.hef batch-size=1 nms-score-threshold=0.3 nms-iou-threshold=0.45 output-format-type=HAILO_FORMAT_TYPE_FLOAT32 ! queue leaky=no max-size-buffers=30 max-size-bytes=0 max-size-time=0 ! hailofilter function-name=yolov5 so-path=/media/fronti/NVMe/hailo_4.15.0/tappas/apps/h8/gstreamer/libs/post_processes//libyolo_hailortpp_post.so config-path=null qos=false ! queue leaky=no max-size-buffers=30 max-size-bytes=0 max-size-time=0 ! hailooverlay qos=false ! queue leaky=no max-size-buffers=30 max-size-bytes=0 max-size-time=0 ! videoconvert "
    multiple_video_processing="$preprocessing $postprocessing"
    no_video_processing=""

    # Encoders
    ecoder_format="video/x-raw(memory:NVMM),format=NV12"
    max_out_resolution=",width=3840,height=2160,$fps"
    no_out_resolution=""
    out_resolution="$no_out_resolution"

    nvh264_enc="nvvidconv ! $ecoder_format $out_resolution ! nvv4l2h264enc ! h264parse"
    swh264_enc="autovideoconvert ! x264enc ! h264parse"
    nvh265_enc="nvvidconv ! $ecoder_format $out_resolution ! nvv4l2h265enc ! h265parse"
    swh265_enc="autovideoconvert ! x265enc ! h264parse"

    # Sinks
    rtspclientsink="rtspclientsink location=rtsp://localhost:8554/stream$stream_id"

    # Final pipeline
    video_processing=$multiple_video_processing
    if [ "$TARGET" == "ORIN" ]; then
        encoder=$nvh264_enc
    else
        encoder=$swh264_enc
    fi
    sink=$rtspclientsink

    if [ "$type" == "file" ]; then
        source=$movie_src_element
        overlay=$no_overlay
    elif [ "$type" == "camera" ] && [ -f "$cam_device" ]; then
        source=$cam_src_element
        overlay=$cam_overlay
    else
        stream_test_pattern
        return 0
    fi

    streaming_pipeline="$source $overlay $video_processing ! $encoder ! $sink"

    debug_print "gst-launch-1.0 -v $streaming_pipeline"

    # Play
    gst-launch-1.0 $streaming_pipeline > /dev/null 2>&1 &
    echo $! > /tmp/gst_pipeline_$id.pid

    # Check if the pipeline is running
    sleep 2
    pid=$(cat /tmp/gst_pipeline_$id.pid)
    if ps -p $pid > /dev/null; then
        echo "$type $id success"
    else
        stream_test_pattern
        return 0
    fi
}

stream_test_pattern() {
    echo "$type $id failed, showing test pattern"

    source=$test_src_element
    overlay=$cam_overlay
    streaming_pipeline="$source $overlay ! $encoder ! $sink"
    debug_print "gst-launch-1.0 -v $streaming_pipeline"

    gst-launch-1.0 $streaming_pipeline > /dev/null 2>&1 &
    echo $! > /tmp/gst_pipeline_$id.pid
    sleep 2

    pid=$(cat /tmp/gst_pipeline_$id.pid)
    if ! ps -p $pid > /dev/null; then
        echo "Test pattern failed"
        rm /tmp/gst_pipeline_$id.pid
    else
        echo "Test pattern success"
    fi
}

stop_stream() {
    type=$1
    id=$2
    if [ -f /tmp/gst_pipeline_$id.pid ]; then
        # Kill the specific GStreamer pipeline process
        kill "$(cat /tmp/gst_pipeline_$id.pid)" > /dev/null 2>&1
        rm /tmp/gst_pipeline_$id.pid
        echo "$type $id stopped"
    else
        echo "$type $id is not running"
    fi
}

case "$1" in
    start)
        if [ "$2" == "camera" ] && [ "$3" == "all" ]; then
            for i in {1..4}; do
                start_stream $2 $i $4 $5
            done
        else
            start_stream $2 $3 $4 $5
        fi
        ;;
    stop)
        if [ "$2" == "camera" ] && [ "$3" == "all" ]; then
            for i in {1..4}; do
                stop_stream $2 $i
            done
        else
            stop_stream $2 $3
        fi
        ;;
    *)
        usage
        exit 1
        ;;
esac
